=== CMakeLists.txt ===

cmake_minimum_required(VERSION 3.10)
project(TeleLibre)

set(CMAKE_CXX_STANDARD 17)

include_directories(include)

# Find required packages
find_package(OpenSSL REQUIRED)
find_package(Boost COMPONENTS system REQUIRED)

# Add executables
add_executable(telelibre 
    src/main.cpp 
    src/KeyManagement.cpp
    src/Networking.cpp
    src/Message.cpp
    src/RoutingTable.cpp
    src/BloomFilter.cpp
)

add_executable(seed_node
    src/seed_node.cpp
    src/Message.cpp  # Add this line to include Message.cpp
)

# Link libraries
target_link_libraries(telelibre 
    OpenSSL::SSL 
    OpenSSL::Crypto 
    Boost::system
    pthread
)

target_link_libraries(seed_node
    Boost::system
    pthread
)


=== include/BloomFilter.h ===

#ifndef BLOOMFILTER_H
#define BLOOMFILTER_H

#include <vector>
#include <string>
#include <functional>

class BloomFilter {
public:
    BloomFilter(size_t size, size_t num_hashes);
    void add(const std::string& item);
    bool probably_contains(const std::string& item) const;

private:
    std::vector<bool> bits_;
    size_t num_hashes_;
    std::hash<std::string> hash_func_;

    size_t hash(const std::string& item, size_t index) const;
};

#endif // BLOOMFILTER_H



=== include/KeyManagement.h ===

#ifndef KEYMANAGEMENT_H
#define KEYMANAGEMENT_H

#include <openssl/evp.h>
#include <string>

class KeyManagement {
public:
    static void generateKeys(EVP_PKEY **privateKey, EVP_PKEY **publicKey);
    static void savePrivateKey(EVP_PKEY *key, const std::string &filename);
    static void savePublicKey(EVP_PKEY *key, const std::string &filename);
    static EVP_PKEY* loadPrivateKey(const std::string &filename);
    static EVP_PKEY* loadPublicKey(const std::string &filename);
    static int signMessage(EVP_PKEY *privateKey, const unsigned char *msg, 
                           size_t msgLen, unsigned char **sig, size_t *sigLen);
    static int verifyMessage(EVP_PKEY *publicKey, const unsigned char *msg, 
                             size_t msgLen, const unsigned char *sig, size_t sigLen);
};

#endif


=== include/Message.h ===

#ifndef MESSAGE_H
#define MESSAGE_H

#include <string>
#include <vector>
#include <ctime>

class Message {
public:
    Message(const std::string& group_id, const std::string& sender_id, const std::string& content);

    std::string message_id;
    std::string group_id;
    std::string sender_id;
    time_t timestamp;
    std::string content;
    std::string signature;
    int ttl;

    std::string serialize() const;
    static Message deserialize(const std::string& serialized);

private:
    static std::string generateMessageId();
};

#endif // MESSAGE_H


=== include/Networking.h ===

#ifndef NETWORKING_H
#define NETWORKING_H

#include <boost/asio.hpp>
#include <string>
#include <vector>
#include <memory>
#include "Message.h"
#include "RoutingTable.h"
#include "BloomFilter.h"
#include "PeerConnection.h"

class Network {
public:
    Network(boost::asio::io_context& io_context, size_t estimated_network_size);
    void bootstrapNetwork(const std::vector<std::string>& seedNodes);
    void sendMessage(const Message& msg);
    void broadcastMessage(const Message& msg);
    void addPeer(std::shared_ptr<PeerConnection> peer);

private:
    boost::asio::io_context& io_context_;
    RoutingTable routing_table_;
    std::vector<std::shared_ptr<PeerConnection>> peers_;
    BloomFilter bloom_filter_;
    size_t estimated_network_size_;

    void handleIncomingMessage(const Message& msg);
    void processPeerList(const std::string& peerListStr);
    bool addPeerIfNew(const std::string& server, const std::string& port);
    void sendPeerList();
    bool shouldForwardMessage() const;
    int calculateFloodRadius() const;
};

std::string computeProofOfWork(const std::string& challenge, int difficulty);

#endif // NETWORKING_H


=== include/PeerConnection.h ===

#ifndef PEERCONNECTION_H
#define PEERCONNECTION_H

#include <boost/asio.hpp>
#include <string>
#include <functional>
#include <memory>
#include "Message.h"

class PeerConnection : public std::enable_shared_from_this<PeerConnection> {
public:
    PeerConnection(boost::asio::io_context& io_context, 
                   const std::string& server, const std::string& port);

    void start();
    void sendMessage(const Message& msg);
    void receiveMessage();
    void setMessageHandler(std::function<void(const Message&)> handler);

    std::string getAddress() const { return server_ + ":" + port_; }

private:
    boost::asio::ip::tcp::socket socket_;
    std::string server_;
    std::string port_;
    boost::asio::streambuf receive_buffer_;
    std::function<void(const Message&)> message_handler_;
};

#endif // PEERCONNECTION_H


=== include/RoutingTable.h ===

#ifndef ROUTINGTABLE_H
#define ROUTINGTABLE_H

#include <string>
#include <unordered_map>
#include <vector>
#include <memory>
#include "PeerConnection.h"

class RoutingTable {
public:
    void addPeer(const std::string& category, std::shared_ptr<PeerConnection> peer);
    std::vector<std::shared_ptr<PeerConnection>> getPeersForCategory(const std::string& category);
    void updatePeerInterests(std::shared_ptr<PeerConnection> peer, const std::vector<std::string>& categories);

private:
    std::unordered_map<std::string, std::vector<std::shared_ptr<PeerConnection>>> table_;
};

#endif // ROUTINGTABLE_H


=== src/BloomFilter.cpp ===

#include "BloomFilter.h"

BloomFilter::BloomFilter(size_t size, size_t num_hashes)
    : bits_(size, false), num_hashes_(num_hashes) {}

void BloomFilter::add(const std::string& item) {
    for (size_t i = 0; i < num_hashes_; ++i) {
        bits_[hash(item, i)] = true;
    }
}

bool BloomFilter::probably_contains(const std::string& item) const {
    for (size_t i = 0; i < num_hashes_; ++i) {
        if (!bits_[hash(item, i)]) {
            return false;
        }
    }
    return true;
}

size_t BloomFilter::hash(const std::string& item, size_t index) const {
    return (hash_func_(item) + index) % bits_.size();
}


=== src/KeyManagement.cpp ===

#include "KeyManagement.h"
#include <openssl/pem.h>
#include <openssl/err.h>
#include <stdexcept>

void KeyManagement::generateKeys(EVP_PKEY **privateKey, EVP_PKEY **publicKey) {
    EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_ED25519, NULL);
    if (!ctx) {
        throw std::runtime_error("Failed to create key context");
    }
    if (EVP_PKEY_keygen_init(ctx) <= 0) {
        EVP_PKEY_CTX_free(ctx);
        throw std::runtime_error("Failed to initialize key generation");
    }
    if (EVP_PKEY_keygen(ctx, privateKey) <= 0) {
        EVP_PKEY_CTX_free(ctx);
        throw std::runtime_error("Failed to generate private key");
    }
    *publicKey = EVP_PKEY_dup(*privateKey);
    EVP_PKEY_CTX_free(ctx);
}

void KeyManagement::savePrivateKey(EVP_PKEY *key, const std::string &filename) {
    FILE *pkey_file = fopen(filename.c_str(), "wb");
    if (!pkey_file) {
        throw std::runtime_error("Failed to open file for writing private key");
    }
    if (PEM_write_PrivateKey(pkey_file, key, NULL, NULL, 0, NULL, NULL) != 1) {
        fclose(pkey_file);
        throw std::runtime_error("Failed to write private key");
    }
    fclose(pkey_file);
}

void KeyManagement::savePublicKey(EVP_PKEY *key, const std::string &filename) {
    FILE *pkey_file = fopen(filename.c_str(), "wb");
    if (!pkey_file) {
        throw std::runtime_error("Failed to open file for writing public key");
    }
    if (PEM_write_PUBKEY(pkey_file, key) != 1) {
        fclose(pkey_file);
        throw std::runtime_error("Failed to write public key");
    }
    fclose(pkey_file);
}

EVP_PKEY* KeyManagement::loadPrivateKey(const std::string &filename) {
    FILE *pkey_file = fopen(filename.c_str(), "rb");
    if (!pkey_file) {
        throw std::runtime_error("Failed to open file for reading private key");
    }
    EVP_PKEY *pkey = PEM_read_PrivateKey(pkey_file, NULL, NULL, NULL);
    fclose(pkey_file);
    if (!pkey) {
        throw std::runtime_error("Failed to read private key");
    }
    return pkey;
}

EVP_PKEY* KeyManagement::loadPublicKey(const std::string &filename) {
    FILE *pkey_file = fopen(filename.c_str(), "rb");
    if (!pkey_file) {
        throw std::runtime_error("Failed to open file for reading public key");
    }
    EVP_PKEY *pkey = PEM_read_PUBKEY(pkey_file, NULL, NULL, NULL);
    fclose(pkey_file);
    if (!pkey) {
        throw std::runtime_error("Failed to read public key");
    }
    return pkey;
}

int KeyManagement::signMessage(EVP_PKEY *privateKey, const unsigned char *msg, 
                               size_t msgLen, unsigned char **sig, size_t *sigLen) {
    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
    if (!mdctx) return -1;

    if (EVP_DigestSignInit(mdctx, NULL, NULL, NULL, privateKey) <= 0) {
        EVP_MD_CTX_free(mdctx);
        return -1;
    }

    if (EVP_DigestSign(mdctx, NULL, sigLen, msg, msgLen) <= 0) {
        EVP_MD_CTX_free(mdctx);
        return -1;
    }

    *sig = (unsigned char *)OPENSSL_malloc(*sigLen);
    if (!(*sig)) {
        EVP_MD_CTX_free(mdctx);
        return -1;
    }

    if (EVP_DigestSign(mdctx, *sig, sigLen, msg, msgLen) <= 0) {
        OPENSSL_free(*sig);
        EVP_MD_CTX_free(mdctx);
        return -1;
    }

    EVP_MD_CTX_free(mdctx);
    return 1;
}

int KeyManagement::verifyMessage(EVP_PKEY *publicKey, const unsigned char *msg, 
                                 size_t msgLen, const unsigned char *sig, size_t sigLen) {
    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
    if (!mdctx) return -1;

    if (EVP_DigestVerifyInit(mdctx, NULL, NULL, NULL, publicKey) <= 0) {
        EVP_MD_CTX_free(mdctx);
        return -1;
    }

    int ret = EVP_DigestVerify(mdctx, sig, sigLen, msg, msgLen);

    EVP_MD_CTX_free(mdctx);
    return ret;
}


=== src/main.cpp ===

#include <iostream>
#include <string>
#include <cstring>
#include <chrono>
#include <thread>
#include "KeyManagement.h"
#include "Networking.h"
#include "Message.h"

int main() {
    std::cout << "TeleLibre: Decentralized Meme Sharing Protocol" << std::endl;

    // Key management test
    EVP_PKEY *privateKey = nullptr;
    EVP_PKEY *publicKey = nullptr;

    try {
        KeyManagement::generateKeys(&privateKey, &publicKey);
        std::cout << "Keys generated successfully." << std::endl;

        KeyManagement::savePrivateKey(privateKey, "private.pem");
        KeyManagement::savePublicKey(publicKey, "public.pem");
        std::cout << "Keys saved to files." << std::endl;

        const char *message_content = "Hello, TeleLibre!";
        unsigned char *signature = nullptr;
        size_t signatureLen = 0;

        if (KeyManagement::signMessage(privateKey, reinterpret_cast<const unsigned char*>(message_content), 
                                       strlen(message_content), &signature, &signatureLen) == 1) {
            std::cout << "Message signed successfully." << std::endl;

            if (KeyManagement::verifyMessage(publicKey, reinterpret_cast<const unsigned char*>(message_content), 
                                             strlen(message_content), signature, signatureLen) == 1) {
                std::cout << "Message verified successfully." << std::endl;
            } else {
                std::cout << "Message verification failed." << std::endl;
            }
        } else {
            std::cout << "Message signing failed." << std::endl;
        }

        OPENSSL_free(signature);
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    EVP_PKEY_free(privateKey);
    EVP_PKEY_free(publicKey);

    // Networking test
    boost::asio::io_context io_context;
    Network network(io_context, 1000);  // Assume an estimated network size of 1000 nodes

    std::vector<std::string> seedNodes = {"127.0.0.1:6881", "127.0.0.1:6882"};
    network.bootstrapNetwork(seedNodes);

    // Send a test message
    Message testMsg("test_group", "test_sender", "This is a test message");
    network.sendMessage(testMsg);

    // Send a test message
    Message testMsg2("test_group", "test_sender", "This is a second test message");
    network.sendMessage(testMsg2);

    // Run the io_context for a short time to allow for message processing
    boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(5));
    timer.async_wait([&io_context](const boost::system::error_code&) { io_context.stop(); });



    io_context.run();

    // Proof of Work test
    std::string challenge = "TeleLibreChallenge";
    int difficulty = 4;
    std::string nonce = computeProofOfWork(challenge, difficulty);
    std::cout << "Proof of Work completed. Nonce: " << nonce << std::endl;

    return 0;
}


=== src/Message.cpp ===

#include "Message.h"
#include <sstream>
#include <iomanip>
#include <random>

Message::Message(const std::string& group_id, const std::string& sender_id, const std::string& content)
    : message_id(generateMessageId()), group_id(group_id), sender_id(sender_id),
      timestamp(std::time(nullptr)), content(content), ttl(10) {}

std::string Message::serialize() const {
    std::stringstream ss;
    ss << message_id << "|" << group_id << "|" << sender_id << "|"
       << timestamp << "|" << content << "|" << signature << "|" << ttl;
    return ss.str();
}

Message Message::deserialize(const std::string& serialized) {
    std::stringstream ss(serialized);
    std::string message_id, group_id, sender_id, content, signature;
    time_t timestamp;
    int ttl;

    std::getline(ss, message_id, '|');
    std::getline(ss, group_id, '|');
    std::getline(ss, sender_id, '|');
    ss >> timestamp;
    ss.ignore();
    std::getline(ss, content, '|');
    std::getline(ss, signature, '|');
    ss >> ttl;

    if (ss.fail() || message_id.empty()) {
        throw std::runtime_error("Failed to parse message: " + serialized);
    }

    Message msg(group_id, sender_id, content);
    msg.message_id = message_id;
    msg.timestamp = timestamp;
    msg.signature = signature;
    msg.ttl = ttl;

    return msg;
}

std::string Message::generateMessageId() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(0, 15);

    const char* hex_chars = "0123456789abcdef";
    std::string uuid;
    for (int i = 0; i < 32; ++i) {
        uuid += hex_chars[dis(gen)];
    }
    return uuid;
}


=== src/Networking.cpp ===

#include "Networking.h"
#include "PeerConnection.h"
#include <iostream>
#include <boost/bind/bind.hpp>
#include <openssl/evp.h>
#include <sstream>
#include <iomanip>
#include <random>
#include <cmath>

PeerConnection::PeerConnection(boost::asio::io_context& io_context, 
                               const std::string& server, const std::string& port)
    : socket_(io_context), server_(server), port_(port) {}

void PeerConnection::start() {
    boost::asio::ip::tcp::resolver resolver(socket_.get_executor());
    auto endpoints = resolver.resolve(server_, port_);
    boost::asio::async_connect(socket_, endpoints,
        [this](boost::system::error_code ec, boost::asio::ip::tcp::endpoint) {
            if (!ec) {
                std::cout << "Connected to " << server_ << ":" << port_ << std::endl;
                receiveMessage();
            } else {
                std::cout << "Failed to connect to " << server_ << ":" << port_ << ": " << ec.message() << std::endl;
            }
        });
}

void PeerConnection::sendMessage(const Message& msg) {
    auto self(shared_from_this());
    std::string serialized = msg.serialize();
    boost::asio::async_write(socket_, boost::asio::buffer(serialized + "\n"),
        [this, self, serialized](boost::system::error_code ec, std::size_t) {
            if (ec) {
                std::cout << "Error sending message to " << server_ << ":" << port_ << ": " << ec.message() << std::endl;
            } else {
                std::cout << "Message sent to " << server_ << ":" << port_ << ": " << serialized << std::endl;
            }
        });
}

void PeerConnection::receiveMessage() {
    auto self(shared_from_this());
    boost::asio::async_read_until(socket_, receive_buffer_, "\n",
        [this, self](boost::system::error_code ec, std::size_t length) {
            if (!ec) {
                std::string serialized;
                std::istream is(&receive_buffer_);
                std::getline(is, serialized);
                std::cout << "Received from " << server_ << ":" << port_ << ": " << serialized << std::endl;

                try {
                    // Check if it's a simple response or a full message
                    if (serialized.find('|') == std::string::npos) {
                        // Simple response
                        if (message_handler_) {
                            Message simpleMsg("", "", serialized);
                            message_handler_(simpleMsg);
                        }
                    } else {
                        // Full message format
                        // Remove any leading characters before the message ID
                        size_t pos = serialized.find('|');
                        if (pos != std::string::npos && pos >= 32) {
                            serialized = serialized.substr(pos - 32);
                        }

                        Message msg = Message::deserialize(serialized);
                        if (message_handler_) {
                            message_handler_(msg);
                        }
                    }
                } catch (const std::exception& e) {
                    std::cout << "Error parsing message from " << server_ << ":" << port_ << ": " << e.what() << std::endl;
                }

                receiveMessage();
            } else {
                std::cout << "Error receiving message from " << server_ << ":" << port_ << ": " << ec.message() << std::endl;
            }
        });
}

void PeerConnection::setMessageHandler(std::function<void(const Message&)> handler) {
    message_handler_ = handler;
}

Network::Network(boost::asio::io_context& io_context, size_t estimated_network_size)
    : io_context_(io_context), 
      bloom_filter_(estimated_network_size * 10, 5),  // Adjust size and number of hash functions as needed
      estimated_network_size_(estimated_network_size) {}


void Network::bootstrapNetwork(const std::vector<std::string>& seedNodes) {
    for (const auto& node : seedNodes) {
        std::string server = node.substr(0, node.find(":"));
        std::string port = node.substr(node.find(":") + 1);

        auto peer = std::make_shared<PeerConnection>(io_context_, server, port);
        peers_.push_back(peer);
        peer->start();

        peer->setMessageHandler([this](const Message& message) {
            handleIncomingMessage(message);
        });
    }

    // Wait for a short time to allow connections to be established
    boost::asio::steady_timer timer(io_context_, boost::asio::chrono::seconds(1));
    timer.async_wait([this](const boost::system::error_code&) {
        Message requestPeersMsg("", "", "RequestPeers");
        broadcastMessage(requestPeersMsg);
    });
}

void Network::sendMessage(const Message& msg) {
    if (bloom_filter_.probably_contains(msg.message_id)) {
        std::cout << "Message already seen, not forwarding: " << msg.message_id << std::endl;
        return;
    }

    bloom_filter_.add(msg.message_id);

    auto peers = routing_table_.getPeersForCategory(msg.group_id);
    if (!peers.empty()) {
        for (const auto& peer : peers) {
            peer->sendMessage(msg);
        }
    } else {
        int flood_radius = calculateFloodRadius();
        for (int i = 0; i < flood_radius && i < peers_.size(); ++i) {
            if (shouldForwardMessage()) {
                peers_[i]->sendMessage(msg);
            }
        }
    }
}

void Network::broadcastMessage(const Message& msg) {
    for (const auto& peer : peers_) {
        if (shouldForwardMessage()) {
            peer->sendMessage(msg);
        }
    }
}

void Network::addPeer(std::shared_ptr<PeerConnection> peer) {
    peers_.push_back(peer);
    peer->setMessageHandler([this](const Message& message) {
        handleIncomingMessage(message);
    });
}
void Network::sendPeerList() {
    std::string peerList;
    for (const auto& peer : peers_) {
        peerList += peer->getAddress() + ",";
    }
    if (!peerList.empty()) {
        peerList.pop_back(); // Remove trailing comma
    }
    Message response("", "", "PeerList: " + peerList);
    sendMessage(response);
    std::cout << "Sent peer list in response to RequestPeers" << std::endl;
}
bool Network::addPeerIfNew(const std::string& server, const std::string& port) {
    for (const auto& peer : peers_) {
        if (peer->getAddress() == server + ":" + port) {
            return false;  // Peer already exists
        }
    }
    auto newPeer = std::make_shared<PeerConnection>(io_context_, server, port);
    peers_.push_back(newPeer);
    newPeer->start();  // Start the connection for the new peer
    return true;  // Peer was added
}

void Network::processPeerList(const std::string& peerListStr) {
    std::istringstream iss(peerListStr);
    std::string peerAddress;
    bool newPeersAdded = false;
    while (std::getline(iss, peerAddress, ',')) {
        std::string server = peerAddress.substr(0, peerAddress.find(":"));
        std::string port = peerAddress.substr(peerAddress.find(":") + 1);
        if (addPeerIfNew(server, port)) {
            newPeersAdded = true;
        }
    }
    if (newPeersAdded) {
        std::cout << "Updated peer list with: " << peerListStr << std::endl;
    } else {
        std::cout << "No new peers added from: " << peerListStr << std::endl;
    }
}


void Network::handleIncomingMessage(const Message& msg) {
    if (msg.content.empty()) {
        std::cout << "Received empty message, ignoring." << std::endl;
        return;
    }

    // For simple responses and PeerList messages, we don't use the Bloom filter
    if (msg.message_id.empty()) {
        if (msg.content == "Message received") {
            std::cout << "Message acknowledged by peer" << std::endl;
        } else if (msg.content.substr(0, 9) == "PeerList:") {
            processPeerList(msg.content.substr(10));
        } else {
            std::cout << "Received simple message: " << msg.content << std::endl;
        }
        return;  // Don't forward simple responses or PeerList messages
    }

    // For full messages, use the Bloom filter
    if (bloom_filter_.probably_contains(msg.message_id)) {
        std::cout << "Message already seen, not processing: " << msg.message_id << std::endl;
        return;
    }

    bloom_filter_.add(msg.message_id);

    if (msg.content == "RequestPeers") {
        sendPeerList();
    } else {
        // Handle other message types
        std::cout << "Received message: " << msg.content << std::endl;
        // Forward the message
        sendMessage(msg);
    }
}
bool Network::shouldForwardMessage() const {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_real_distribution<> dis(0, 1);

    const double C = 1000.0;  // Adjust this constant as needed
    return dis(gen) < (C / estimated_network_size_);
}

int Network::calculateFloodRadius() const {
    return static_cast<int>(std::ceil(std::log2(estimated_network_size_)));
}

std::string computeProofOfWork(const std::string& challenge, int difficulty) {
    int nonce = 0;
    std::string hash;

    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
    const EVP_MD *md = EVP_sha256();

    while (true) {
        std::stringstream ss;
        ss << challenge << nonce;
        
        unsigned char hash_raw[EVP_MAX_MD_SIZE];
        unsigned int hash_len;

        EVP_DigestInit_ex(mdctx, md, NULL);
        EVP_DigestUpdate(mdctx, ss.str().c_str(), ss.str().length());
        EVP_DigestFinal_ex(mdctx, hash_raw, &hash_len);

        std::stringstream hash_ss;
        for (unsigned int i = 0; i < hash_len; i++) {
            hash_ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash_raw[i];
        }
        hash = hash_ss.str();

        if (hash.substr(0, difficulty) == std::string(difficulty, '0')) {
            EVP_MD_CTX_free(mdctx);
            return std::to_string(nonce);
        }

        nonce++;
    }
}


=== src/RoutingTable.cpp ===

#include "RoutingTable.h"
#include <algorithm>

void RoutingTable::addPeer(const std::string& category, std::shared_ptr<PeerConnection> peer) {
    table_[category].push_back(peer);
}

std::vector<std::shared_ptr<PeerConnection>> RoutingTable::getPeersForCategory(const std::string& category) {
    if (table_.find(category) != table_.end()) {
        return table_[category];
    }
    return {};
}

void RoutingTable::updatePeerInterests(std::shared_ptr<PeerConnection> peer, const std::vector<std::string>& categories) {
    // Remove the peer from all categories
    for (auto& entry : table_) {
        auto& peers = entry.second;
        peers.erase(std::remove(peers.begin(), peers.end(), peer), peers.end());
    }

    // Add the peer to the specified categories
    for (const auto& category : categories) {
        addPeer(category, peer);
    }
}


=== src/seed_node.cpp ===

#include <boost/asio.hpp>
#include <iostream>
#include <string>
#include <sstream>
#include "Message.h"

using boost::asio::ip::tcp;

class Session : public std::enable_shared_from_this<Session> {
public:
    Session(tcp::socket socket) : socket_(std::move(socket)) {}

    void start() {
        do_read();
    }

private:
    void do_read() {
        auto self(shared_from_this());
        boost::asio::async_read_until(socket_, buffer_, "\n",
            [this, self](boost::system::error_code ec, std::size_t length) {
                if (!ec) {
                    std::string serialized(boost::asio::buffers_begin(buffer_.data()),
                                           boost::asio::buffers_begin(buffer_.data()) + length - 1);
                    buffer_.consume(length);

                    // Find the first '|' character and start parsing from there
                    size_t pos = serialized.find('|');
                    if (pos != std::string::npos && pos >= 32) {
                        serialized = serialized.substr(pos - 32);
                    }

                    std::cout << "Received: " << serialized << std::endl;
                    
                    try {
                        Message msg = Message::deserialize(serialized);
                        std::cout << "Received message: " << msg.content << std::endl;
                        if (msg.content == "RequestPeers") {
                            do_write("PeerList: 127.0.0.1:6881,127.0.0.1:6882\n");
                        } else {
                            do_write("Message received\n");
                        }
                    } catch (const std::exception& e) {
                        std::cout << "Error parsing message: " << e.what() << std::endl;
                        do_write("Error: Invalid message format\n");
                    }
                }
                do_read();
            });
    }

    void do_write(std::string msg) {
        auto self(shared_from_this());
        boost::asio::async_write(socket_, boost::asio::buffer(msg),
            [this, self](boost::system::error_code ec, std::size_t /*length*/) {
                if (ec) {
                    std::cerr << "Error writing response: " << ec.message() << std::endl;
                }
            });
    }

    tcp::socket socket_;
    boost::asio::streambuf buffer_;
};


class Server {
public:
    Server(boost::asio::io_context& io_context, short port)
        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)) {
        do_accept();
    }

private:
    void do_accept() {
        acceptor_.async_accept(
            [this](boost::system::error_code ec, tcp::socket socket) {
                if (!ec) {
                    std::make_shared<Session>(std::move(socket))->start();
                }

                do_accept();
            });
    }

    tcp::acceptor acceptor_;
};

int main(int argc, char* argv[]) {
    try {
        if (argc != 2) {
            std::cerr << "Usage: seed_node <port>\n";
            return 1;
        }

        boost::asio::io_context io_context;

        Server s(io_context, std::atoi(argv[1]));

        std::cout << "Seed node running on port " << argv[1] << std::endl;

        io_context.run();
    } catch (std::exception& e) {
        std::cerr << "Exception: " << e.what() << "\n";
    }

    return 0;
}


